---
title: 第五章 - 引用类型
date: 2020-03-21 02:19:07
tags: JS
comments: false
---
本章内容 
- 使用对象 
- 创建并操作数组 
- 理解基本的 JavaScript 类型 
- 使用基本类型和基本包装类型 

引用类型的值（即对象）是**引用类型**的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为**对象定义**，因为它们描述的是一类对象所具有的属性和方法。被称为类并不妥当，因为它不具备传统的面向对象语言所支持的类和接口等基本结构。
新对象是使用 new 操作符后跟一个**构造函数**来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。
```js
var person = new Object();
```
这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。

## 5.1 Object 类型 
**创建 Object 实例**的方式有两种。
第一种是使用 new 操作符后跟 Object 构造函数：
```js
var person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
```
另一种方式是使用对象字面量表示法：
```js
var person = { 
    name : "Nicholas", 
    age : 29 
};
```
在使用对象字面量语法时，属性名也可以使用字符串。
> 在通过对象字面量定义对象时，实际上不会调用 Object 构造函数。

际上，对象字面量是向函数传递大量可选参数的首选方式，例如：
```js
function displayInfo(args) { 
    var output = ""; 
 
    if (typeof args.name == "string"){ 
        output += "Name: " + args.name + "\n"; 
    } 
 
    if (typeof args.age == "number") { 
        output += "Age: " + args.age + "\n"; 
    } 
 
    alert(output); 
} 
 
displayInfo({  
    name: "Nicholas",  
    age: 29 
}); 
 
displayInfo({ 
    name: "Greg" 
}); 
```
函数 displayInfo()接受一个名为 args的参数。这个参数可能带有一个名为 name或 age 的属性，也可能这两个属性都有或者都没有。
> 这种传递参数的模式最适合需要向函数传入大量可选参数的情形。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。 
**访问对象属性**时可使用点表示法，也可以使用方括号表示法。
通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。 

## 5.2 Array 类型 
与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。（可从对象的角度来理解）
**创建数组**的基本方式有两种。第一种是使用 Array 构造函数：
```js
var colors = new Array(); 
var colors = new Array(3); // 创建一个包含 3 项的数组 
var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组
```
另外，在使用 Array 构造函数时也可以省略 new 操作符。
第二种基本方式是使用数组字面量表示法：
```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组 
var names = []; // 创建一个空数组 
```
在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引。（因为用点访问属性为数字实在是太奇怪了啊）
数组的**length 属性**的值为数组中最大索引值+1（数组最后一项的索引始终是 length-1）；而且通过设置可以从数组的末尾移除项或向数组中添加新项。

### 5.2.1 检测数组 
对于一个网页，或者一个全局作用域而言，使用 **instanceof** 操作符即可，但如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。
为了解决这个问题，ECMAScript 5 新增了 **Array.isArray()**方法：
```js
if (Array.isArray(value)){ 
    //对数组执行某些操作 
} 
```

### 5.2.2 转换方法 
如前所述，所有对象都具有 toLocaleString()、toString()和 valueOf()方法。其中，调用数组的 **toString()方法**会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 **valueOf()**返回的还是数组。
```js
var colors = ["red", "blue", "green"];
colors.toString(); // "red,blue,green"
colors.valueOf(); // ["red", "blue", "green"]
colors; // ["red", "blue", "green"]
```
而如果使用 **join()方法**，则可以使用不同的分隔符来构建这个字符串（不传默认使用逗号分隔）：
```js
var colors = ["red", "green", "blue"]; 
console.log(colors.join(","));       // "red,green,blue" 
console.log(colors.join("||"));      // "red||green||blue"
```

### 5.2.3 栈方法 
ECMAScript 为数组专门提供了 **push()**和 **pop()**方法，以便实现类似栈的行为。 
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

### 5.2.4 队列方法 
队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）。弹出第一项并返回的方法为**shift()**，再结合**push()**方法。
ECMAScript 还为数组提供了一个 **unshift()**方法：能在数组前端添加任意个项并返回新数组的长度。同时**使用 unshift()和 pop()**方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。

### 5.2.5 重排序方法 
数组中已经存在两个可以直接用来重排序的方法：**reverse()和 sort()**。
- sort()方法：
默认按升序排列数组项。为了实现排序，sort()方法会**调用每个数组项的 toString()**转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。
sort()方法可以接收一个**比较函数**作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数：
```js
function compare(value1, value2) { 
    if (value1 < value2) { 
        return -1; //看负数在哪，顺序就在哪
    } else if (value1 > value2) { 
        return 1; 
    } else { 
        return 0; 
    } 
}
var values = [0, 1, 5, 10, 15]; 
values.sort(compare); 
alert(values); //0,1,5,10,15 
```
对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可使用更简单的比较函数：
```js
function compare(value1, value2){ 
    return value2 - value1; 
}
```

### 5.2.6 操作方法 
**concat()**方法可以基于当前数组中的所有项创建一个新数组：
```js
var colors = ["red", "green", "blue"]; 
var colors2 = colors.concat("yellow", ["black", "brown"]); 
 
alert(colors);     //red,green,blue         
alert(colors2);    //red,green,blue,yellow,black,brown 
```

**slice()**方法它能够基于当前数组中的一或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
```js
var colors = ["red", "green", "blue", "yellow", "purple"]; 
var colors2 = colors.slice(1); 
var colors3 = colors.slice(1,4); 
 
alert(colors2);   //green,blue,yellow,purple 
alert(colors3);   //green,blue,yellow 
```
> 如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。

**splice()**方法比较强大（会修改原数组），始终都会返回一个数组，该数组中包含从原始数组中删除的项。使用方式有三种：
- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。
- 可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。

### 5.2.7 位置方法 
两个位置方法：**indexOf()**和**lastIndexOf()**。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从数组的开头（位置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 

### 5.2.8 迭代方法
定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。给出5个迭代方法的作用：
- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。（用于过滤） 
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。（类似for循环迭代数组） 
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

以上方法都不会修改数组中的包含的值。 

### 5.2.9 归并方法 
ECMAScript 5 还新增了两个归并数组的方法：**reduce()**和 **reduceRight()**。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 （区别取决于要从哪头开始遍历数组）
reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 
```js
var values = [1,2,3,4,5]; 
var sum = values.reduce(function(prev, cur, index, array){ 
    return prev + cur;  
}); 
alert(sum); //15 
```

## 5.3 Date 类型

